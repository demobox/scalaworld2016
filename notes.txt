
0-5min: Intro, Agenda, Aim

5-15min: What can we learn from looking at puzzlers?
  * "cluster analysis" - are there features of the language that are especially puzzler-prone?
  * inherent vs. accidental complexity - which potentially confusing parts could we avoid/get rid of vs. which seem unavoidable given the design goals of the language

15-45min: A couple of examples
  * Pick an Int, Any Int! - inherent (inheritance & JVM compat)?
  * Cast Away - inherent (JVM compat)?
  * Now You See Me, Now You Don't - inherent (inheritance)?
  * Stringy Conversions - accidental (conciseness gone too far?)
  * Think of 1 Card - accidental (undefined precedence rules?)?
  * "varargs eta" - accidental (conciseness gone too far?)
  * Applied Values - accidental (compiler optimization leaking out?)
  * Init You, Init Me - ?
  * A Listful of Dollars - ?

45-55min: What can you do today to make things better?
  * use a linter
  * have a style guide
  * use warnings
  * use compiler plugins
  * ...but these are all "opt-in", and that is always challenging

55-60min: What changes with Dotty?
  * Quick overview of which puzzlers are "slain" with and without -language:Scala2

  * Dmitry's thoughts on whether it would make sense to try to get rid of more, or whether that would be too much of a challenge from an engineering perspective, or isn't important enough, or would present too much of a backwards-compatibility problem, or...?

60-90min: The Death of DelayedInit
  * All yours ;-)